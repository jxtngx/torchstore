<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="2" skipped="0" tests="2" time="17.667" timestamp="2025-09-05T11:51:33.827477-07:00" hostname="devgpu011.ldc3.facebook.com"><testcase classname="tests.test_store" name="test_objects[strategy_params0-False]" time="8.260"><failure message="TypeError: 'ActorEndpoint' object is not callable">strategy_params = (2, &lt;torchstore.strategy.LocalRankStrategy object at 0x7f8b4838d1e0&gt;)
use_rdma = False

    @pytest.mark.parametrize(*transport_plus_strategy_params())
    @pytest.mark.asyncio
    async def test_objects(strategy_params, use_rdma):
        """Test basic put/get functionality for multiple processes"""
        os.environ["TORCHSTORE_RDMA_ENABLED"] = "1" if use_rdma else "0"
    
        class ObjectActor(Actor):
            """Each instance of this actor represents a single process."""
            def __init__(
                self,
                world_size,
            ):
                init_logging()
                self.world_size = world_size
                self.rank = current_rank().rank
                # required by LocalRankStrategy
                os.environ["LOCAL_RANK"] = str(self.rank)
            @endpoint
            async def put(self, obj):
                await ts.put(f"key_{self.rank}", obj)
            @endpoint
            async def get(self, rank_offset=0):
                other_rank = (self.rank + rank_offset) % self.world_size
                return await ts.get(f"key_{other_rank}")
    
        volume_world_size, strategy = strategy_params
        await torchstore.initialize(
            num_storage_volumes=volume_world_size,
            strategy=strategy
        )
        # each actor mesh represents a group of processes.
        actor_mesh_0 = await spawn_actors(volume_world_size, ObjectActor, "actor_mesh_0", world_size=volume_world_size)
        actor_mesh_1 = await spawn_actors(volume_world_size, ObjectActor, "actor_mesh_1", world_size=volume_world_size)
    
        class MyTestObject:
            def __init__(self, val):
                self.val = val
    
        try:
            for idx in range(volume_world_size):
                actor = actor_mesh_0.slice(**{"hosts":0, "gpus": idx})
&gt;               await actor.put(
                    MyTestObject(idx)
                )
E               TypeError: 'ActorEndpoint' object is not callable

tests/test_store.py:119: TypeError</failure></testcase><testcase classname="tests.test_store" name="test_objects[strategy_params1-False]" time="8.130"><failure message="TypeError: 'ActorEndpoint' object is not callable">strategy_params = (1, None), use_rdma = False

    @pytest.mark.parametrize(*transport_plus_strategy_params())
    @pytest.mark.asyncio
    async def test_objects(strategy_params, use_rdma):
        """Test basic put/get functionality for multiple processes"""
        os.environ["TORCHSTORE_RDMA_ENABLED"] = "1" if use_rdma else "0"
    
        class ObjectActor(Actor):
            """Each instance of this actor represents a single process."""
            def __init__(
                self,
                world_size,
            ):
                init_logging()
                self.world_size = world_size
                self.rank = current_rank().rank
                # required by LocalRankStrategy
                os.environ["LOCAL_RANK"] = str(self.rank)
            @endpoint
            async def put(self, obj):
                await ts.put(f"key_{self.rank}", obj)
            @endpoint
            async def get(self, rank_offset=0):
                other_rank = (self.rank + rank_offset) % self.world_size
                return await ts.get(f"key_{other_rank}")
    
        volume_world_size, strategy = strategy_params
        await torchstore.initialize(
            num_storage_volumes=volume_world_size,
            strategy=strategy
        )
        # each actor mesh represents a group of processes.
        actor_mesh_0 = await spawn_actors(volume_world_size, ObjectActor, "actor_mesh_0", world_size=volume_world_size)
        actor_mesh_1 = await spawn_actors(volume_world_size, ObjectActor, "actor_mesh_1", world_size=volume_world_size)
    
        class MyTestObject:
            def __init__(self, val):
                self.val = val
    
        try:
            for idx in range(volume_world_size):
                actor = actor_mesh_0.slice(**{"hosts":0, "gpus": idx})
&gt;               await actor.put(
                    MyTestObject(idx)
                )
E               TypeError: 'ActorEndpoint' object is not callable

tests/test_store.py:119: TypeError</failure></testcase></testsuite></testsuites>